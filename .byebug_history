skip
c
params
c
@products.where(name: 'Молоко').count
@products.where(name: 'Молоко').countc
c
@products.where(name: 'Молоко').countc
@products.where(name: 'Молоко').count
@products.where(name: 'Молоко')
c
@products.count
@products 
c
params 
c
params 
product_params 
c
OrderBlueprint.render(filtered_orders)
OrderBlueprinter.render(filtered_orders)
OrderBlueprin.render(filtered_orders)
paginate_orders.class
filtered_orders.class
filtered_orders
c
@orders
c
params[:orders]
params[:filtered_orders]
c
params[:orders]
paramsp[:orders]
c
@orders.count
@orders.size
@orders
c
@users = PaginationService.new(@users, MAX_ITEMS_ON_PAGE).call(params[:page]).includes(:role, :orders)
 @users = UserSearchService.new(User.all).call(params)
c
     @users = PaginationService.new(@users, MAX_ITEMS_ON_PAGE).call(params[:page]).includes(:role, :orders)
@users = UserSearchService.new(User.all).call(params)
c
@users = PaginationService.new(@users, MAX_ITEMS_ON_PAGE).call(params[:page]).includes(:role, :orders)
@users = UserSearchService.new(User.all).call(params)
max_page
map_page
c
 UserBlueprint.render(
          @users)
 @users = PaginationService.new(@users, MAX_ITEMS_ON_PAGE).call(params[:page]).includes(:role, :orders)
   13:         @users = PaginationService.new(@users, MAX_ITEMS_ON_PAGE).call(params[:page]).includes(:role, :orders)
@users = UserSearchService.new(User.all).call(params)
max_page
c
next
step
sorts[param.to_sym]
c
next
help
current_user.errors.messages 
current_user.update(profile_params) ? 1 : 2
params 
profile_params
exit
params[:favorites].to_i
params[:favorites].to_b
params[:favorites].to_c
params[:favorites].to_d
params[:favorites].to_r
params[:favorites].to_b
params[:favorites].false?
params[:favorites]
skip
options
skip
options[:current_user].favorite_ids.include?(object.id)
object.id
options[:current_user].favorite_ids
options[:current_user].favorite_ids.include?(product_id: object.id)
object.name
object.id
c
object.id
c
object.id
options[:current_user].favorite_ids
skip
c
params[:page]
c
params[:page].class
params[:page]
c
params[:page]
skip
c
url_for.send(:owner)
url_for.owner
url_for().owner
url_for.owner
url_for
url_for.class
url_for.superclass
url_for
url_for(1)
url_for(dsa)
url_for(dsa
url_for
url_for(Product.first.image)
skip
c
currentUser && currentUser.cart && hasProduct
options[:current_user].count_ordered_product(object.id)
object.id
opbject.id
options[:current_user].count_ordered_product()
options[:current_user].count_ordered_product
options[:current_user]..count_ordered_product
options[:current_user]
options
exit
session.options 
session.methods
session.class
session[:user]
session[:user_id]
session
current_user
c
request.session
request.authenticated?
request.user
request.user_agent
request.remote_ip
request.headers['X-My-Header']
request.query_parameters
request.method
request
request.referer
request.path
request.env
request.from
request.body
request.origin
request.auth_type
request.auth_type\
request.request_id
request.controller_class
request.xhr?
request.flash_hash
request.methods
request
c
record.user == user 
record.user = user 
record.user
record
c
record
c
user
record.user
record
c
ss
s
n
s
ss
s
help
s
n
c
Message.last
n
Message.last
@message.errors
@message
n
@message 
c
@message
params
c
params
c
params
c
chat_params[:user_id]
chat_params
@chat.errors.methods
@chat.errors.attribute
@chat.errors
@chat.valid?
mm.valid?
mm = @chat.messages.build(text: chat_params[:title], user_id: chat_params[:user_id])
m = @chat.messages.build(text: chat_params[:title], user_id: chat_params[:user_id])
@chat.messages.build(text: chat_params[:title], user_id: chat_params[:user_id])
@chat.errors.messages
@chat.errors
@chat.valid?
@chat.messages.build(text: chat_params[:title])
@chat
chat_params
c
chat_params
c
exit
params.require(:chat).permit(:user_id, messages_attributes: %i[text user_id])
params
c
params.require(:chat).permit(:user_id, messages_attributes: %i[text user_id])
params
c
cc
c
params
c
params
c
params
c
params
c
params
c
@elements.count
@elements
@elemets
c
User.limit(2).class
@elements.class
@elements
@elements.class
@elements.count
c
@users
c
hhh[param.to_symc]
hhh[param.to_sym]
hhh[param]
h[param]
param
hhh
c
h
c
params[:sort_by].present?
params
@users
c
@users
