c
 product = Product.find(product_id:)
c
step
next
step
c
step
c
step
next
step
up
step
help
c
up
list
help
back
up
next
up
down
up
uo
step
Product.find(params[:product_id])
params[:product_id]
c
resource
resoyrce
c
resource.save
resource.errors
resource.valid?
resource 
c
PaginationService.new(messages, MAX_ITEMS_ON_PAGE).pagin(2)
PaginationService.new(messages, MAX_ITEMS_ON_PAGE).pagin(1)
c
 PaginationService.new(messages, MAX_ITEMS_ON_PAGE).infinite_scroll(2c
 PaginationService.new(messages, MAX_ITEMS_ON_PAGE).infinite_scroll(2)
 PaginationService.new(messages, MAX_ITEMS_ON_PAGE).infinite_scroll(1)
 PaginationService.new(messages, MAX_ITEMS_ON_PAGE).infinite_scroll(params[:page])
@elements.page(@elements.count / @max_elements_on_page).per(@max_elements_on_page)
@elements.page(@elements.count / @max_elements_on_page)
@elements.count / @max_elements_on_page
@elements.count
@max_elements_on_page
c
PaginationService.new(messages, MAX_ITEMS_ON_PAGE).call(5).count
PaginationService.new(messages, MAX_ITEMS_ON_PAGE).call(3).count
PaginationService.new(messages, MAX_ITEMS_ON_PAGE).call(2).count
PaginationService.new(messages, MAX_ITEMS_ON_PAGE).call(params[:page]).count
params[:page]
skip
c
params
c
@products.where(name: 'Молоко').count
@products.where(name: 'Молоко').countc
c
@products.where(name: 'Молоко').countc
@products.where(name: 'Молоко').count
@products.where(name: 'Молоко')
c
@products.count
@products 
c
params 
c
params 
product_params 
c
OrderBlueprint.render(filtered_orders)
OrderBlueprinter.render(filtered_orders)
OrderBlueprin.render(filtered_orders)
paginate_orders.class
filtered_orders.class
filtered_orders
c
@orders
c
params[:orders]
params[:filtered_orders]
c
params[:orders]
paramsp[:orders]
c
@orders.count
@orders.size
@orders
c
@users = PaginationService.new(@users, MAX_ITEMS_ON_PAGE).call(params[:page]).includes(:role, :orders)
 @users = UserSearchService.new(User.all).call(params)
c
     @users = PaginationService.new(@users, MAX_ITEMS_ON_PAGE).call(params[:page]).includes(:role, :orders)
@users = UserSearchService.new(User.all).call(params)
c
@users = PaginationService.new(@users, MAX_ITEMS_ON_PAGE).call(params[:page]).includes(:role, :orders)
@users = UserSearchService.new(User.all).call(params)
max_page
map_page
c
 UserBlueprint.render(
          @users)
 @users = PaginationService.new(@users, MAX_ITEMS_ON_PAGE).call(params[:page]).includes(:role, :orders)
   13:         @users = PaginationService.new(@users, MAX_ITEMS_ON_PAGE).call(params[:page]).includes(:role, :orders)
@users = UserSearchService.new(User.all).call(params)
max_page
c
next
step
sorts[param.to_sym]
c
next
help
current_user.errors.messages 
current_user.update(profile_params) ? 1 : 2
params 
profile_params
exit
params[:favorites].to_i
params[:favorites].to_b
params[:favorites].to_c
params[:favorites].to_d
params[:favorites].to_r
params[:favorites].to_b
params[:favorites].false?
params[:favorites]
skip
options
skip
options[:current_user].favorite_ids.include?(object.id)
object.id
options[:current_user].favorite_ids
options[:current_user].favorite_ids.include?(product_id: object.id)
object.name
object.id
c
object.id
c
object.id
options[:current_user].favorite_ids
skip
c
params[:page]
c
params[:page].class
params[:page]
c
params[:page]
skip
c
url_for.send(:owner)
url_for.owner
url_for().owner
url_for.owner
url_for
url_for.class
url_for.superclass
url_for
url_for(1)
url_for(dsa)
url_for(dsa
url_for
url_for(Product.first.image)
skip
c
currentUser && currentUser.cart && hasProduct
options[:current_user].count_ordered_product(object.id)
object.id
opbject.id
options[:current_user].count_ordered_product()
options[:current_user].count_ordered_product
options[:current_user]..count_ordered_product
options[:current_user]
options
exit
session.options 
session.methods
session.class
session[:user]
session[:user_id]
session
current_user
c
request.session
request.authenticated?
request.user
request.user_agent
request.remote_ip
request.headers['X-My-Header']
request.query_parameters
request.method
request
request.referer
request.path
request.env
request.from
request.body
request.origin
request.auth_type
request.auth_type\
request.request_id
request.controller_class
request.xhr?
request.flash_hash
request.methods
request
c
record.user == user 
record.user = user 
record.user
record
c
record
c
user
record.user
record
c
ss
s
n
s
ss
s
help
s
n
c
Message.last
n
Message.last
@message.errors
@message
n
@message 
c
@message
params
c
params
c
params
c
chat_params[:user_id]
chat_params
@chat.errors.methods
@chat.errors.attribute
@chat.errors
@chat.valid?
mm.valid?
mm = @chat.messages.build(text: chat_params[:title], user_id: chat_params[:user_id])
